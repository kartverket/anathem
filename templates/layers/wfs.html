<%doc>
description: include a WFS layer in the base map
params:
  url: Base URL of the WMTS
  layerGroup: include layer in this layer group (used by menus and layer selectors to display only layers belonging to the same group)
  visible: Set visibility of the layer
  hidefromlayerswitcher: if set, the layer will not appear in any menu or layer switcher
  styleName: style definition to be used for this layer
  styleNameSLD: SLD to be used as a style for this layer
  popup: (TEMPLATE) a popup definition to be used to display metadata for this layer
  version: WFS version parameter
  id: short id to be used to identify this layer in the client URL
  name: Name of the layer to be displayed in menus etc.
  namespace: namespace of data in the WFS service
  namespacePrefix: prefix for the namespace of data in the WFS service
  featuretype: featuretype to be requested from the WFS service
  todo:
    databbox: set the maximum bounding box for displaying this layer. The map client will not attempt to load tiles outside this bounding box, comma separated. (OpenLayers parameter maxExtent)
    dataURL: hint for the export tool where data or images from this layer can be downloaded via a supported download service (WMS/WFS)
    dataLayers: hint for the export tool which LAYERS (WMS) or TYPE (WFS) should be used when downloading data.
    dataType: hint for the export tool which service type to use for downloading data ["wms" or "wfs"]
    dataFormats: hint for the export tool which data formats are supported by the data service (comma separated list of MIME types)

</%doc>
<%include file="/functions/vector.html"/>

% if popup:
  <%include file="/functions/popup.html"/>
% endif

% if cluster:
  <%include file="/strategies/cluster.html"/>
% endif

% if not 'layerTypeWFS' in vars:

NK.addLayerType = NK.addLayerType || {};
NK.addLayerType.WFS = (function (M, MP) {
	return function (name, id, url, featureNS, featurePrefix, featureType, options) {

		var protocolParameters,
			protocol,
			layer,
			layerOptions;

		if (!!options.method && options.method == "GET") {
			protocolParameters = {
				url        : '/ws/px.py?' + url,
				origUrl    : url,
				featureType: featureType,
				params     : {
					request     : "GetFeature",
					service     : "WFS",
					typename    : featureType,
					srsName     : options.epsg || "EPSG:" + NK.baseProjection,
					version     : options.version || '1.1.0',
					outputFormat: options.outputFormat || 'text/xml; subtype=gml/3.2.1'
				},
				format     : new OpenLayers.Format.GML.v3(),
				srsInBBOX  : true
			};
			protocol = new OpenLayers.Protocol.HTTP(protocolParameters);
		} else {
			var readFormatOptions = {
				featureNS    : "http://www.opengis.net/gml/3.2",
				featurePrefix: 'gml',
			};
			protocolParameters = {
				version      : options.version || '1.1.0',
				url          : '/ws/px.py?' + url,
				proxyUrl     : '/ws/px.py?' + url,
				srsName     : options.epsg || "EPSG:" + NK.baseProjection, // @TODO: get the srs from capabilities and check against default, if necessary transform or cast an error
				origUrl      : url,
				featureNS    : featureNS,
				featurePrefix: featurePrefix,
				featureType  : featureType,
				outputFormat : options.outputFormat || 'text/xml; subtype=gml/3.2.1',
				readFormat   : new OpenLayers.Format.GML.v3(readFormatOptions)
			};
			protocol = new OpenLayers.Protocol.WFS(protocolParameters);
		}

		layerOptions = {
			strategies            : [new OpenLayers.Strategy.BBOX()],
			shortid               : id,
			protocol              : protocol,
			projection            : MP,
			displayInLayerSwitcher: (options && options.hideFromLayerSwitcher) ? 0 : 1,
			visibility            : !!(options.visibility) ? 1 : 0
		};

		if (options.styleName && NK.styles && NK.styles[options.styleName]) {
			layerOptions.styleMap = NK.styles[options.styleName];
		}

		if (options.styleNameSLD && NK.styles && NK.styles.SLD && NK.styles.SLD[options.styleNameSLD]) {
			layerOptions.styleMap = NK.styles.SLD[options.styleNameSLD];
		}

		if (options.cluster && NK.strategies.cluster) {
			layerOptions.strategies.push(NK.strategies.cluster);
		}

		layer = new OpenLayers.Layer.Vector(
			name,
			layerOptions
		);

		//monkey patch to send BBOX as WGS84
		/* layer.strategies[0].calculateBounds = function(mapBounds) {
		 if(!mapBounds) {
		 mapBounds = this.getMapBounds();
		 }
		 var center = mapBounds.getCenterLonLat();
		 var dataWidth = mapBounds.getWidth() * this.ratio;
		 var dataHeight = mapBounds.getHeight() * this.ratio;
		 this.bounds = new OpenLayers.Bounds(
		 center.lon - (dataWidth / 2),
		 center.lat - (dataHeight / 2),
		 center.lon + (dataWidth / 2),
		 center.lat + (dataHeight / 2)
		 );
		 this.bounds = this.bounds.clone().transform( map.projection , NK.projections[4326] );
		 return this.bounds;
		 };
		 layer.strategies[0].activate();
		 */

		layer.events.register("loadend", layer, function (evt) {
			if (evt.response && evt.response.priv) {
				if (!!evt.response.priv.responseXML){
					var root = evt.response.priv.responseXML.firstChild;
					if (root.localName == "ExceptionReport") {
						NK.functions.log(root.textContent.trim());
					}
				}
			}
		});

		if (options.cluster) {
			NK.styles.addClusteringRule(layer.styleMap);
		}

		if (options && options.layerGroup) {
			layer = OpenLayers.Util.extend(layer, {'layerGroup': options.layerGroup});
		}

		if (options && options.visibility) {
			NK.defaultVisibleLayers = NK.defaultVisibleLayers || [];
			NK.defaultVisibleLayers.push(id);
		}

		M.addLayers([layer]);

		if (options.styleNameSLD && NK.styles && NK.styles.SLD && NK.styles.SLD[options.styleNameSLD]) {
			NK.functions.setSLDStyleForLayer(options.styleNameSLD, layer);
		}

		//NK.functions.vector.addVectorHoverControls(M, layer, false);
		NK.functions.popup.addConfiguredPopup(M, layer, options.popupConfig);

		return layer;
	};
}(map, mapProj));

<% vars['layerTypeWFS']=True %>
% endif

% if name: 
## do nothing if name is not given - useful to just include the functions above

(function() {
	var options = {};

% if layerGroup:
	options.layerGroup = "${layerGroup}";	
% endif

% if visible:
	options.visible = ${visible};	
% endif

% if hidefromlayerswitcher:
	options.hideFromLayerSwitcher = "${hidefromlayerswitcher}";	
% endif

% if cluster:
	options.cluster = true;
% endif

% if styleName:
	options.styleName = '${styleName}';
% endif

% if styleNameSLD:
	options.styleNameSLD = '${styleNameSLD}';
% endif

% if popup:
  options.popupConfig = ${popup};
% endif

% if useToken:
  options.token = NK.gkToken;
% endif

% if version:
  options.version = '${version}';
% endif

% if visible:
  options.visibility = true;
% endif

  NK.addLayerType.WFS("${name}", "${id}", "${url}", "${namespace}", "${namespacePrefix}", "${featuretype}", options);	
}());

% endif
