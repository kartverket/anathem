
% if cluster:
  <%include file="/strategies/cluster.html"/>
%endif

%if not 'layerTypeGeoJSONfile' in vars:
NK.addLayerType = NK.addLayerType || {};

NK.addLayerType.geoJSONFile = (function (M, MP, P) {
  return function (id, name, url, options) {
    var layer,
        layerOptions,
        strategies = [],
        requestHandler;

    layerOptions = {
      shortid: id, 
      styleMap: NK.styles.omriss, 
      visibility: true,
      strategies: []
    };

    if (options.styleName && NK.styles && NK.styles[options.styleName]) {
      layerOptions.styleMap = NK.styles[options.styleName];
    }

    if (options.styleNameSLD && NK.styles && NK.styles.SLD && NK.styles.SLD[options.styleName]) {
      layerOptions.styleMap = NK.styles[options.styleName];
    }

    if (options.cluster && NK.strategies.cluster) {
      layerOptions.strategies.push(NK.strategies.cluster);
    }

    // context to style the vectorlayer
    var context = {
        getColor: function(feature){
            var color = '#aaaaaa';
            if (feature.attributes && feature.attributes) {
                color = '#ee0000';
            } else if(feature.cluster) {
                var onlyFour = true;
                for (var i = 0; i < feature.cluster.length; i++) {
                    if (onlyFour && feature.cluster[i].attributes) {
                        onlyFour = false;
                    }
                }
                if (onlyFour === true) {
                    color = '#ee0000';
                }
            }
            return color;
        }
    };
    
    layer = new OpenLayers.Layer.Vector(
      name,
      layerOptions
    );

    if (options.cluster) {
      NK.styles.addClusteringRule(layer.styleMap);
    }

    M.addLayer(layer);

    requestHandler = function (request) {
      var geojsonFormat,
          features,
          formatOptions;

      formatOptions = {
        'internalProjection': MP,
        'externalProjection': MP 
      };
  
      if (options.epsgCode && P[options.epsgCode]) {
        formatOptions.externalProjection = P[options.epsgCode];
      }
  
      geojsonFormat = new OpenLayers.Format.GeoJSON(formatOptions);


      features = geojsonFormat.read(request.responseText);


      layer.addFeatures(features);

    };

    OpenLayers.Request.GET({
      'url': url,
      'callback': requestHandler
    });
  }
}(map, mapProj, proj));

<% vars['layerTypeGeoJSON']=True %>
%endif

(function () {
  var options = {};
%if epsgCode:
  options.epsgCode = '${epsgCode}';
% endif

% if cluster:
  options.cluster = true;
% endif

% if styleName:
  options.styleName = '${styleName}';
% endif

% if styleNameSLD:
  options.styleNameSLD = '${styleNameSLD}';
% endif

  NK.addLayerType.geoJSONFile('${id}', '${name}', '${url}', options);
}());
