<%doc>
description: Template to include a WMTS layer in the map.
params: 
  url: Base URL of the WMTS
  layerGroup: include layer in this layer group (used by menus and layer selectors to display only layers belonging to the same group)
  epsg: use a projection code differing from the map base projection, e.g. for compatible WGS vs. ETRS codes (optional)
  extent: set the maximum bounding box for displaying this layer. The map client will not attempt to load tiles outside this bounding box, comma separated. (deprecated, OpenLayers parameter tileFullExtent)
  databbox: set the maximum bounding box for displaying this layer. The map client will not attempt to load tiles outside this bounding box, comma separated. (OpenLayers parameter maxExtent)
  dataURL: hint for the export tool where data or images from this layer can be downloaded via a supported download service (WMS/WFS)
  dataLayers: hint for the export tool which LAYERS (WMS) or TYPE (WFS) should be used when downloading data.
  dataType: hint for the export tool which service type to use for downloading data ["wms" or "wfs"] 
  dataFormats: hint for the export tool which data formats are supported by the data service (comma separated list of MIME types)
  tileorigin: tile origin (top left corner) of the WMTS layer, comma separated (optional, sets OpenLayers parameter of the same name) 
  isBaseLayer: "'true' if this layer is to be used as the map base layer"
  id: short id to be used to identify this layer in the client URL 
  name: Name of the layer to be displayed in menus etc.
  layer: WMTS layer name requested from the service
  attribution: Attribution string
  abstract: Service description
</%doc>
% if not 'layerTypeWMTS' in vars:

NK.addLayerType = NK.addLayerType || {};
NK.addLayerType.WMTS = (function (M, MP) {
  var matrixIds = [],
      i;

  for (i = 0; i <= NK.zoomLevels; ++i) {
    matrixIds[i] = {};
    matrixIds[i].identifier = MP + ":" + i;
  } 

  return function (id, name, url, layer, options) {
    var layer, 
        layerOptions;
    var myMatrixIds = matrixIds;

    if (!!options.customProj) {
      var myMatrixIds = [],
        i;

      for (i = 0; i <= NK.zoomLevels; ++i) {
        myMatrixIds[i] = {};
        if (!!options.shortMatrixIds) {
          myMatrixIds[i].identifier = "" + i;
        } else {
          myMatrixIds[i].identifier = options.customProj + ":" + i;
        }
      } 
    } 

    layerOptions = {
      'name': name,
      'url': url,
      'layer': layer,
      'matrixSet': options.customProj || MP,
      'matrixIds': myMatrixIds,
      'format': "image/png",
      'requestEncoding': "kvp",
      'style': "default",
      'shortid': id, 
      'transitionEffect': 'resize',
      'displayOutsideMaxExtent': false,
      'buffer': 4
    };
    layerOptions["isBaseLayer"] = !!options.isBaseLayer;

    if (!!options.extent) {
      var c = options.extent.split(",");
      var customBounds = new OpenLayers.Bounds(c);
      layerOptions['tileFullExtent'] = customBounds;
    }
    if (!!options.tileorigin) {
      var c = options.tileorigin.split(",");
      var origin = new OpenLayers.LonLat(c);
      layerOptions['tileOrigin'] = origin;
    }
    if (!!options.databbox) {
      var c = options.databbox.split(",");
      var customBounds = new OpenLayers.Bounds(c);
      layerOptions['maxExtent'] = customBounds;
      layerOptions['visibility'] = 1;
    }

    layerOptions.displayInLayerSwitcher = !!(options.displayInLayerSwitcher) ? 1 : 0;
    layerOptions.visibility = !!(options.visibility) ? 1 : 0;

    if (!!options.params) {
      layerOptions.params = options.params;
    }

    layer = new OpenLayers.Layer.WMTS(layerOptions);

    if (options.layerGroup) {
      layer = OpenLayers.Util.extend(layer, {
        'layerGroup': options.layerGroup
      });
    }

    if (options.dataURL) {
      layer.dataURL     = options.dataURL;
      layer.dataLayers  = options.dataLayers;
      layer.dataType    = options.dataType;
      layer.dataFormats = options.dataFormats.split(",");
    }
    if (!!options.hideOverview) {
      layer.hideOverview = true;  
    }

    layer.description = options.abstract;
    layer.attribution = {"title":options.attribution};

    if (layer.params.GKT) {
      layer.params.gkt = layer.params.GKT;
      delete layer.params.GKT; 
    }

    if (options.visible) {
      NK.defaultVisibleLayers = NK.defaultVisibleLayers || [];
      NK.defaultVisibleLayers.push(id);
    }

    layer.events.register("tileerror", layer, function(arg) {
      NK.functions.getNewToken();
    });

    M.addLayers([layer]);
  };
}(map, mapProj));

<% vars['layerTypeWMTS']=True %>
% endif

(function () {
  var url, 
      options = {};

  % if url:
    url = "${url}";
  % else:
    url = NK.mapservers.wmts;
  % endif

  % if hidefromlayerswitcher:
    options.displayInLayerSwitcher = false;
  % else:
    options.displayInLayerSwitcher = true;
  % endif

  % if visible:
    options.visibility = true;
  % endif

  % if layerGroup:
    options.layerGroup = "${layerGroup}";
  % endif

  % if usetoken:
    options.params = { 'gkt': NK.gkToken };
  % endif

  % if epsg:
    options.customProj = "${epsg}"
  % endif

  % if shortMatrixIds:
    options.shortMatrixIds = true
  % endif

  % if extent:
    options.extent = "${extent}"
  % endif

  % if databbox:
    options.databbox = "${databbox}"
  % endif

  % if hideOverview:
    options.hideOverview = true
  % endif

  % if dataURL:
    options.dataURL     = "${dataURL}"
    options.dataLayers  = "${dataLayers}"
    options.dataType    = "${dataType}"
    options.dataFormats = "${dataFormats}"
  % endif

  % if tileorigin:
    options.tileorigin = "${tileorigin}"
  % endif

  % if isBaseLayer:
    options.isBaseLayer = "${isBaseLayer}"
  % endif

  % if attribution:
    options.attribution = "${attribution}"
  % endif

  % if abstract:
    options.abstract = "${abstract}"
  % endif



  NK.addLayerType.WMTS('${id}', '${name}', url, '${layer}', options);
}());
