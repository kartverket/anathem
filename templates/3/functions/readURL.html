<%doc>
description: |
  this utility function reads the hash state from the URL and loads/enables map layers accordingly. 
  current URL syntax is:
     #zoom/x/y/parameter/parameter
  * zoom is the map zoom level 
  * x is the x coordinate of the map
  * y is the y coordinate of the map
  optional parameters map include
  * +layer sets a layer visibility
  * -layer removes a layer visibility if it is turned on by the default configuration
  * !layer!feature highlights a named feature on the map in the given layer (deprecated) 
  * !layer@x,y highlights a feature on the map at the given location 
  * m/x/y/text adds a marker with a popup on the map
  * w/url=... adds a WMS layer to the map (deprecated)
  * l/type/[url] adds an overlay to the map. Valid types include 'wms', 'wfs', 'geojson' and 'drawing'
  * d/type/[url] adds a data layer to the last added overlay. Valid types include 'wfs' and 'wcs'
  * o# sets opacity to the last added overlay. # is a float value between 0.0 and 1.0.
</%doc> 
// parameters for layers that are loaded asynchronously
NK.visibleLayerQueue = NK.visibleLayerQueue || {}; 
NK.opacityQueue = NK.opacityQueue || {}; 
NK.highlightQueue = NK.highlightQueue || {}; 

NK.functions.storeInitialLayerVisibility = function () {
  // store the initial layer visibility configuration
  var i, 
      layer;

  NK.initLayers = [];

  for (i in map.layers) {
    if (map.layers.hasOwnProperty(i)) {
      layer = map.layers[i];
      if (layer.visibility) {
        if ((!NK.defaultVisibleLayers || !$.inArray(layer.shortid, NK.defaultVisibleLayers)) && !layer.isUrlDataLayer) {
          NK.initLayers.push(layer.shortid);
        }
      }
    }
  }
};

NK.functions.setMapStateFromPopState = function (evt) {
  if (evt && evt.originalEvent && evt.originalEvent.state) {
    NK.functions.setMapState({'search': evt.originalEvent.state.search, 'hash': evt.originalEvent.state.hash});
  }
};

$(window).on('popstate', NK.functions.setMapStateFromPopState);

var markerStyle = new ol.style.Style({
  image: new ol.style.Icon({
    anchor: [12, 57],
    anchorXUnits: 'pixels',
    anchorYUnits: 'pixels',
    src: 'data:image/png;base64,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'
  })
});

NK.functions.addLabeledMarker = function (params, number) {
  var layer, feature, properties, x, y, popup, element;

  layer = NK.util.getLayersBy('shortid','pekere');
  if (layer.length) {
    layer = layer[0];
  } else {
    layer = new ol.layer.Vector({
      title: 'pekere',
      isHelper: true,
      source: new ol.source.Vector()
    });
    map.addLayer(layer);
  }

  x = parseInt(params[0], 10);
  y = parseInt(params[1], 10);

  properties = {};

  if (params.length > 2) {
    properties.name = decodeURIComponent(params[2]);
  }  
  if (number) {
    properties.nr = number;
  } else {
    properties.nr = '';
  }

  feature = new ol.Feature($.extend(properties,{
    geometry: new ol.geom.Point([x, y])
  }));
  feature.setStyle(markerStyle);

  element =  document.createElement('div');
  map.getViewport().appendChild(element);
  popup = new ol.Overlay({
    element: element,
    positioning: 'bottom-center',
    stopEvent: false
  });
  popup.setPosition([x,y]);
  popup.setOffset([9,-48]);
  map.addOverlay(popup);

  $(element).popover({
    placement: 'top',
    html: true,
    content: feature.get('name')
  });
  $(element).popover('show');

  layer.getSource().addFeature(feature);
  return feature;

};

NK.functions.verifyDataLayers = function(layer) {
  if (!!layer.dataUrl) {return;}
  for (var url in NK.dataLayers) {
    var data = NK.dataLayers[url];
    if (data.layerUrl == layer.url) {
      layer.dataUrl = url;
      layer.dataType = data.type;
      layer.dataName = data.name;
      layer.dataLayers = data.layers;
      layer.dataFormats = data.formats;
      layer.dataConstraints = data.constraints;
      layer.dataAttribution = data.attribution;
    }
  }
}

NK.functions.setDataLayer = function(params) {
  var type, url;
  if (!NK.lastParsedLayer) { 
    NK.functions.log(OpenLayers.Lang.translate("Data Layer provided without Portrayal Layer.<br/>Use /l/ before providing /d/."));
    return;
  } 
  type = params[0];
  url  = params[1];
  if (url.indexOf("%")>-1) { // you can URL-encode or escape or both
    url = decodeURIComponent(url);
  }
  switch (type) {
    case 'wcs':
      var last = NK.lastParsedLayer;
      NK.functions.loadWCSLayer(url, function(wcs) {
        NK.dataLayers[url] = {
          "type": type,
          "formats": wcs.formats,
          "layers": wcs.layers,
          "name": wcs.title,
          "attribution": wcs.attribution,
          "constraints": wcs.constraints,
          "layerUrl": last
        }
      });
      break;
  }
} 

NK.functions.parseParamsAndAddDataLayerFromUrl = function (params) {
  var type, url;

  type = params[0];
  url  = params[1];
  if (url.indexOf("%")>-1) { // you can URL-encode or escape or both
    url = decodeURIComponent(url);
  }

  switch (type) {
    case 'geojson':
      NK.functions.addGeoJsonLayer(url, "32633"); //FIXME: hardcoding EPSG code, should move to all WGS as per the latest GeoJSON memorandum
      break;
    case 'drawing':
      NK.functions.addGeoJsonLayer(url, "32633", {'isDrawing': true});
      break;
    case 'wms':
      NK.functions.addWMSLayer(url);
      break;
    case 'wfs':
      NK.functions.addWFSLayer(url);
      break;
    case 'wcs':
      NK.functions.log(OpenLayers.Lang.translate("Cannot display WCS directly. Use a Portrayal Service WMS with WCS as data layer.<br/>Syntax: /l/wms/[URL to portrayal]/d/wcs/[URL to data]"));
      break;
  }
  NK.lastParsedLayer = url;
};

NK.functions.addGeoJsonLayer = function (url, epsgCode, extensionProperties) {
  var mapProjection,
      formatOptions,
      geoJSONFormat,
      layerOptions,
      layer,
      correctEpsgCode,
      layerExtensions;

  formatOptions = {
    'internalProjection': map.getProjection(),
    'externalProjection': map.getProjection()
  };

  /* set external projection, if provided  */

  if (epsgCode && NK.projections[epsgCode]) {
    formatOptions.externalProjection = NK.projections[epsgCode];
    correctEpsgCode = epsgCode;
  } else {
    correctEpsgCode = NK.baseProjection;
  }

  geoJSONFormat = new OpenLayers.Format.GeoJSON(formatOptions);

  layerOptions = {
    shortid: 'urlDataLayer_' + NK.functions.urlDataLayerCounter, 
    protocol: new OpenLayers.Protocol.HTTP({
      'url': url,
      'format': geoJSONFormat
    }),
    strategies: [new OpenLayers.Strategy.Fixed({preload: true, autoActivate: true})],
    styleMap: NK.styles.track,
    projection: mapProjection,
    displayInLayerSwitcher: false,
    visibility: true
  };

  layer = new OpenLayers.Layer.Vector(
    'urlDataLayer_' + NK.functions.urlDataLayerCounter++,
    layerOptions
  );

  layerExtensions = {
    'isUrlDataLayer': true,
    'type': 'geojson',
    'epsgCode': correctEpsgCode,
    'url': url
  };

  if (extensionProperties) {
    layerExtensions = OpenLayers.Util.extend(layerExtensions, extensionProperties); 
  }

  layer = OpenLayers.Util.extend(layer, layerExtensions);

  map.addLayers([layer]);
};

NK.functions.highlightFeature = function(layer, fid, coords) { 
   // works for fid, does not work for spatial
   var filter; 

   if (!!coords) {
     var delta = 1;
     filter = new OpenLayers.Filter.Spatial({ type:  OpenLayers.Filter.Spatial.BBOX, 
                                              value: new OpenLayers.Bounds(coords[0]-delta, coords[1]-delta, (coords[0]-1)+delta, (coords[1]-1)+delta)
                                            });
   } else {
     filter = new OpenLayers.Filter.FeatureId({ fids: fid });
   }
   /* set a new renderer rule to highlight elements with the given name */
   layer.styleMap.styles['default'].addRules([
          new OpenLayers.Rule({
            filter: filter,
            symbolizer: {
              strokeWidth: 3,
              strokeColor : "orange",
              graphicZIndex: 2,
              fillColor : "orange",
              fillOpacity: 0.1
            }
          }),
          new OpenLayers.Rule({
            elseFilter: true,
            symbolizer: {}
          })
    ]);

    layer.styleMap.styles.temporary.addRules([
          new OpenLayers.Rule({
            filter: filter,
            symbolizer: {
              strokeWidth: 3,
              strokeColor: "yellow",
              fillColor  : "orange",
              fillOpacity: 0.2,
              graphicZIndex: 100
            }
          }),
          new OpenLayers.Rule({
            elseFilter: true,
            symbolizer: {}
          })
    ]);
};

NK.functions.urlDataLayerCounter = 0;
NK.functions.setMapState = function (params) {
  var parms,
      zoom,
      mapx,
      mapy,
      xy,
      index,
      extra,
      setLayerVisibility,
      setOpacity,
      showLayerNamed,
      hideLayerNamed,
      highlight,
      search,
      searchArray,
      searchInputField,
      i, j, p,
      hash,
      labeledMarkerCount = 0,
      pWSG84,
      pUTM33;

  var SAFE_SEQUENCE = "\n\n"; // a separator that cannot occur in URL

  search = params.search;
  hash = params.hash;


  if (params.search) {
    search = search.replace('?', '');
    searchArray = search.split('&');
    for (i = 0, j = searchArray.length; i < j; i += 1) {
      p = searchArray[i].split('=');
      if (p[0] === 'sok') {
        p[1] = decodeURIComponent(p[1]);
        searchInputField = document.getElementById('searchInput');
        if (searchInputField) {
          searchInputField.value = p[1];
        }
        //map.events.triggerEvent('searchForPhrase', {'phrase': p[1]});
      }
    }
  }

  if (!!hash) {
    var tokens = [], match;
    if (hash.indexOf("[") > -1) {
      var tokenRE = /\[.*?\]/g ;
      while(!!(match = tokenRE.exec(hash))) {
        tokens.push(match[0].slice(1,-1)); 
      }
      hash = hash.replace(tokenRE, SAFE_SEQUENCE);
    } else if (hash.indexOf("%5B") > -1) {
      var tokenRE = /\%5B.*?\%5D/g ;
      while(!!(match = tokenRE.exec(hash))) { 
        tokens.push(match[0].slice(3,-3)); 
      }
      hash = hash.replace(tokenRE, SAFE_SEQUENCE);
    }
    var parms = hash.split("/");
    for (p in parms) {
      if (parms[p] == SAFE_SEQUENCE) {
        parms[p] = tokens.shift(); // pop first
      }
    }
    if (parms.length >= 3) {
      zoom = parms[0];
      mapx = parms[1];
      mapy = parms[2];

      if ((mapy > 0) && (mapy < 35) && (mapx > 50) && (mapx < 90)) {  /* we are dealing with WSG84 coordinates here */
        xy = ol.proj.transform([mapy, mapx], 'EPSG:4326', map.getView().getProjection());
        mapx = xy.x;
        mapy = xy.y;
      }
    }

    setLayerVisibility = function (layer, visibility, opacity) {
      var i, 
          j,
          layer,
          layerSwitcherPresent;

      if (opacity === undefined) {opacity=1.0;}
      //layerSwitcherPresent =  map.getControlsByClass('OpenLayers.Control.RasterOverlayLayerSwitcher').length > 0;

      layer.setOpacity(opacity);
      //if (layerSwitcherPresent && visibility && layer.displayInLayerSwitcher && !layer.isBaseLayer && (layer.CLASS_NAME === "OpenLayers.Layer.WMTS" || layer.CLASS_NAME === "OpenLayers.Layer.WMS")) {
      //  map.events.triggerEvent('rasterLayerChangeRequest', {'shortId': layerName});
      //} else {
        layer.setVisible(visibility);
      //}
    };

    showLayerNamed = function (layerName) {
      NK.lastAddedLayer = layerName;
      var found = false;
      $(map.getLayers().getArray()).filter(function(i,l) {
        return (l.get('shortid') == layerName) || (l.get('title') == layerName); // TODO: or layer id for WMS
      }).each(function(i,l) {
        found = true;
        setLayerVisibility(l, true);
      });
      if (!found) {
        NK.visibleLayerQueue[layerName]=true;
      }
    };
    
    setOpacity = function(value) {
      if (!NK.lastAddedLayer) return;
      var matches = NK.util.getLayersBy('shortid', NK.lastAddedLayer);
      if (matches.length) {
        $.each(matches, function(i,l) {
          setLayerVisibility(l, true, parseInt(value)/100.0);
        });
      } else {
        NK.opacityQueue[NK.lastAddedLayer]=parseInt(value)/100.0;
      }
    }

    highlight = function (highlightParam) {
      var select, 
          layers,
          layer;

      select = highlightParam.slice(1).split("!");
      layers = map.getBy("layers", "shortid", select[0]);

      if (layers.length === 1) {
        layer = layers[0];
        //TODO: handle coordinates
        NK.functions.highlightFeature(layer, select[1]);
      } else {
        var q = NK.highlightQueue[select[0]] || [];
        if (select[1].indexOf(",")>-1) {
          q.push([select[0], null, select[1].split(",")]);
        } else {
          q.push([select[0], select[1], null]);
        }
        NK.highlightQueue[select[0]] = q;
      }
    }


    for (index = 3; index < parms.length; index += 1) {
      extra = parms[index];
      switch (extra.charAt(0)) {
        case '+':
          showLayerNamed(extra.slice(1));
          break;
        case '!':
          highlight(extra);
          break;
        case 'o':
          setOpacity(extra.slice(1));
          break;
        case 'm':
          setTimeout(
            (function (boundParameters, boundCounter){
              return function () {
                NK.functions.addLabeledMarker(boundParameters, boundCounter);  
              };
            }(parms.slice(index + 1, index + 4), ++labeledMarkerCount)),
            500
          );
          index += 3;
          break;
        case 'l':
          NK.functions.parseParamsAndAddDataLayerFromUrl(parms.slice(index + 1, index + 3));
          index += 2;
          break;
        case 'd':
          NK.functions.setDataLayer(parms.slice(index + 1, index + 3))
          index += 2;
          break; 
      }
    }
    if (mapx && mapy && zoom) {
      map.getView().setCenter([parseInt(mapx), parseInt(mapy)]);
      map.getView().setZoom(zoom);
    }
  }
};

NK.functions.setMapStateFromURL = function () {
  // adjust layer visibility and pan/zoom based on hash, if available

  var hash,
      search;

  search = window.location.search;
  hash = window.location.href.split("#")[1]; // avoids window.location.hash because Firefox automatically decodes URI encoded hashes


  NK.functions.setMapState({'search': search, 'hash': hash});
};
